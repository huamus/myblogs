const e=JSON.parse('{"key":"v-e5f9f10c","path":"/knowledgeBase/xiaolinCoding/4.Redis/7.cacheChapter/2.html","title":"2. 数据库和缓存如何保证一致性？","lang":"zh-CN","frontmatter":{"title":"2. 数据库和缓存如何保证一致性？","description":"一天，老板说「最近公司的用户越来越多了，但是服务器的访问速度越来越差的，阿旺帮我优化下，做好了给你画个饼！」。 程序员阿旺听到老板口中的「画饼」后就非常期待，没有任何犹豫就接下了老板给的这个任务。 阿旺登陆到了服务器，经过一番排查后，确认服务器的性能瓶颈是在数据库。 这好办，给服务器加上 Redis，让其作为数据库的缓存。 这样，在客户端请求数据时，如果能在缓存中命中数据，那就查询缓存，不用在去查询数据库，从而减轻数据库的压力，提高服务器的性能。 先更新数据库，还是先更新缓存？","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myblogs/knowledgeBase/xiaolinCoding/4.Redis/7.cacheChapter/2.html"}],["meta",{"property":"og:site_name","content":"huamus"}],["meta",{"property":"og:title","content":"2. 数据库和缓存如何保证一致性？"}],["meta",{"property":"og:description","content":"一天，老板说「最近公司的用户越来越多了，但是服务器的访问速度越来越差的，阿旺帮我优化下，做好了给你画个饼！」。 程序员阿旺听到老板口中的「画饼」后就非常期待，没有任何犹豫就接下了老板给的这个任务。 阿旺登陆到了服务器，经过一番排查后，确认服务器的性能瓶颈是在数据库。 这好办，给服务器加上 Redis，让其作为数据库的缓存。 这样，在客户端请求数据时，如果能在缓存中命中数据，那就查询缓存，不用在去查询数据库，从而减轻数据库的压力，提高服务器的性能。 先更新数据库，还是先更新缓存？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-02T14:35:37.000Z"}],["meta",{"property":"article:author","content":"huamus"}],["meta",{"property":"article:modified_time","content":"2023-07-02T14:35:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2. 数据库和缓存如何保证一致性？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-02T14:35:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"huamus\\",\\"url\\":\\"https://huamus.github.io/mynotes/\\"}]}"]]},"headers":[{"level":2,"title":"先更新数据库，再更新缓存","slug":"先更新数据库-再更新缓存","link":"#先更新数据库-再更新缓存","children":[]},{"level":2,"title":"先更新缓存，再更新数据库","slug":"先更新缓存-再更新数据库","link":"#先更新缓存-再更新数据库","children":[]},{"level":2,"title":"先删除缓存，再更新数据库","slug":"先删除缓存-再更新数据库","link":"#先删除缓存-再更新数据库","children":[]},{"level":2,"title":"先更新数据库，再删除缓存","slug":"先更新数据库-再删除缓存","link":"#先更新数据库-再删除缓存","children":[{"level":3,"title":"重试机制","slug":"重试机制","link":"#重试机制","children":[]},{"level":3,"title":"订阅 MySQL binlog，再操作缓存","slug":"订阅-mysql-binlog-再操作缓存","link":"#订阅-mysql-binlog-再操作缓存","children":[]}]}],"git":{"createdTime":1688308537000,"updatedTime":1688308537000,"contributors":[{"name":"huamus","email":"1943805462@qq.com","commits":1}]},"readingTime":{"minutes":16.38,"words":4915},"filePathRelative":"knowledgeBase/xiaolinCoding/4.Redis/7.cacheChapter/2.md","localizedDate":"2023年7月2日","excerpt":"<p>一天，老板说「最近公司的用户越来越多了，但是服务器的访问速度越来越差的，阿旺帮我优化下，<strong>做好了给你画个饼！</strong>」。</p>\\n<p>程序员阿旺听到老板口中的「画饼」后就非常期待，没有任何犹豫就接下了老板给的这个任务。</p>\\n<p>阿旺登陆到了服务器，经过一番排查后，确认服务器的<strong>性能瓶颈是在数据库</strong>。</p>\\n<p>这好办，给服务器加上 Redis，让其作为数据库的缓存。</p>\\n<p>这样，在客户端请求数据时，如果能在缓存中命中数据，那就查询缓存，不用在去查询数据库，从而减轻数据库的压力，提高服务器的性能。</p>\\n<h1> 先更新数据库，还是先更新缓存？</h1>","autoDesc":true}');export{e as data};
