const e=JSON.parse('{"key":"v-5f32b719","path":"/knowledgeBase/xiaolinCoding/3.MySQL/4.transactionChapter/2.html","title":"2. MySQL 可重复读隔离级别，完全解决幻读了吗？","lang":"zh-CN","frontmatter":{"title":"2. MySQL 可重复读隔离级别，完全解决幻读了吗？","author":"huamus","isOriginal":false,"data":"2023-8-14","description":"原文链接：https://xiaolincoding.com/ 作者：小林coding MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/myblogs/knowledgeBase/xiaolinCoding/3.MySQL/4.transactionChapter/2.html"}],["meta",{"property":"og:site_name","content":"huamus"}],["meta",{"property":"og:title","content":"2. MySQL 可重复读隔离级别，完全解决幻读了吗？"}],["meta",{"property":"og:description","content":"原文链接：https://xiaolincoding.com/ 作者：小林coding MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-29T08:17:07.000Z"}],["meta",{"property":"article:author","content":"huamus"}],["meta",{"property":"article:modified_time","content":"2023-08-29T08:17:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2. MySQL 可重复读隔离级别，完全解决幻读了吗？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-29T08:17:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"huamus\\"}]}"]]},"headers":[{"level":2,"title":"什么是幻读？","slug":"什么是幻读","link":"#什么是幻读","children":[]},{"level":2,"title":"快照读是如何避免幻读的？","slug":"快照读是如何避免幻读的","link":"#快照读是如何避免幻读的","children":[]},{"level":2,"title":"当前读是如何避免幻读的？","slug":"当前读是如何避免幻读的","link":"#当前读是如何避免幻读的","children":[]},{"level":2,"title":"幻读被完全解决了吗？","slug":"幻读被完全解决了吗","link":"#幻读被完全解决了吗","children":[{"level":3,"title":"第一个发生幻读现象的场景","slug":"第一个发生幻读现象的场景","link":"#第一个发生幻读现象的场景","children":[]},{"level":3,"title":"第二个发生幻读现象的场景","slug":"第二个发生幻读现象的场景","link":"#第二个发生幻读现象的场景","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1688308537000,"updatedTime":1693297027000,"contributors":[{"name":"huamus","email":"1943805462@qq.com","commits":2}]},"readingTime":{"minutes":8.16,"words":2447},"filePathRelative":"knowledgeBase/xiaolinCoding/3.MySQL/4.transactionChapter/2.md","localizedDate":"2023年7月2日","excerpt":"<blockquote>\\n<p>原文链接：<a href=\\"https://xiaolincoding.com/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://xiaolincoding.com/</a></p>\\n<p>作者：小林coding</p>\\n</blockquote>\\n<p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>\\n<ul>\\n<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>\\n<li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>\\n</ul>","autoDesc":true}');export{e as data};
